---
title: "Mixing Rcpp modules and Rcpp attributes"
author: "Bob Jansen"
license: GPL (>= 2)
tags: basics attributes modules
summary: How to use Rcpp modules in combination with Rcpp attributes
---

### Introduction

With Rcpp modules (Eddelbuettel and Francois, 2017) it is easy to expose
\proglang{C++} classes and functions to \proglang{R}. This note describes how
to use exported classes in conjunction with functions exported using Rcpp
attributes (Eddelbuettel and Francois, 2017) using Rcpp attributes
(Eddelbuettel and Francois, 2017) through the use of
\code{RCPP_EXPOSED\*} macros.

Exporting \proglang{C++} functions is simple thanks to Rcpp attributes. Just
add a single specially formatted comment line to each function as follows:

```{r engine="Rcpp"}
#include <Rcpp.h>

// [[Rcpp::export]]
void shout(std::string message) {
  Rcpp::Rcout << message << "!" << std::endl;
}
```
Now, calling this function from \code{R} is as easy as one can hope:
```{r}
shout("Hello World")
```

Exporting \proglang{C++} classes can be done using Rcpp modules. It uses a
different mechanism and requires a bit more work. The simple class \code{Echo}
below has a \code{get()} method which returns the original constructor
parameter.

```{r engine="Rcpp", eval=FALSE}
#include <Rcpp.h>
#include <string>

using namespace Rcpp;

class Echo {
private:
    std::string message;
public:
    Echo(std::string message) : message(message) {}

    std::string get() {
      return message;
    }
};
```

This simple class can now be exposed to R by specifing the constructors and the
methods that should be callable from R along

```{r engine="Rcpp", eval=FALSE}
RCPP_MODULE(echo_module) {
    class_<Echo>("Echo")
    .constructor<std::string>()
    .method("get", &Echo::get)
    ;
};
```

Unfortunately, combining these two snippets as is creates a problem. The Rcpp
attributes machinery that exports \code{shout()} will not be automagically
aware of the \code{Echo} class. This will cause a _link time error_ when
building the package as the functionality that transforms the class between a
\code{SEXP} and a regular \proglang{C++} object is not created. The solution is
simple: instruct the compiler to do so explicitly using the
\code{RCPP_EXPOSED\*} family of macros.  In the current case it suffices to add
```{r engine="Rcpp", eval=FALSE}
RCPP_EXPOSED_AS(Echo)
```
Now the code can be compiled and using the \proglang{C++} is as in the earlier
examples.

```{r engine="Rcpp", echo=FALSE}
// All code is put into this one block to allow compilation.
#include <Rcpp.h>
#include <string>

using namespace Rcpp;

class Echo {
private:
    std::string message;
public:
    Echo(std::string message) : message(message) {}

    std::string get() {
      return message;
    }
};

RCPP_MODULE(echo_module) {
    class_<Echo>("Echo")
    .constructor<std::string>()
    .method("get", &Echo::get)
    ;
};

RCPP_EXPOSED_CLASS(Echo) // The magic line
```

Now, using the class from \proglang{R} is easy:

```{r}
echo <- new(Echo, "Hello World")
echo$get()
shout(echo$get())
```

### The \code{RCPP_EXPOSED\*} macros

Rcpp defines a number \code{RCPP_EXPOSED\*}macros in
\code{inst/include/Rcpp/macros/module.h}, the most important ones are

- \code{RCPP_EXPOSED_AS}  which allows passing objects from \proglang{R} to
  \proglang{C++}. As seen above, this is needed when exported functions want to
  take a \proglang{C++} object as argument. Other uses include methods and
  constructors of other Rcpp modules classes that take a \proglang{C++} object
  as argument;
- \code{RCPP_EXPOSED_WRAP} which allows the other way around; This is needed
  when a exported function or method wants to return a \proglang{C++} object;
- \code{RCPP_EXPOSED_CLASS} which allows both.

