---
title: Custom progress bars for RcppProgress
author: Karl Forner and Clemens Schmid
license: GPL (>= 2)
tags: progress bar
summary: Demonstrates how to implement custom progress bars for long computations in C++.
---

[RcppProgress](http://cran.r-project.org/web/packages/RcppProgress/index.html) 
is a tool to help you monitor the execution time of your C++ code, by
providing a way to interrupt the execution inside the C++ code, and also to
display a progress bar indicative of the state of your computation. Additionally, 
it is compatible with multithreaded code, for example using OpenMP. 
[This article](http://gallery.rcpp.org/articles/using-rcppprogress/) explains the 
basic setup.

Since version 0.4 it became more simple to create custom progress bars. We will 
show here how to do this. Our final example implementation displays an estimate of the remaining time (ETA). You can find a complete package setup with the code for this ETA progress bar [here](https://github.com/kforner/rcpp_progress/tree/master/inst/examples/RcppProgressETA). 

### A minimal example

Imagine you added a progress bar with RcppProgress to your function
`long_computation()` following the example from the first article mentioned above.

```{Rcpp long_computation}
// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
#include <progress_bar.hpp>
// [[Rcpp::export]]
double long_computation(int nb, bool display_progress=true) {
    double sum = 0;
    Progress p(nb*nb, display_progress);
    for (int i = 0; i < nb; ++i) {
        if (Progress::check_abort() )
            return -1.0;
        for (int j = 0; j < nb; ++j) {
            p.increment(); 
            sum += R::dlnorm(i+j, 0.0, 1.0, 0);
        }
    }
    return sum + nb;
}
```

```{r long_computation_call}
long_computation(10)
```

You can now create your own implementation of a progress bar class. It has to be
derived from the abstract class `ProgressBar` that defines some basic virtual
methods:

```{Rcpp ProgressBar, eval=FALSE}
class ProgressBar {
  public:
    virtual ~ProgressBar() = 0;
    virtual void display() = 0;
    virtual void update(float progress) = 0;
    virtual void end_display() = 0;
};
```

`display()` starts the display, that will be updated by subsequent calls of
`update()`. `end_display` finalizes it. Your progress bar implementation should
not rely on the destructor to finalize the display.

A minimal setup could look something like this: 

```{Rcpp minbar, eval = TRUE}
#include <R_ext/Print.h>

// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
#include "progress_bar.hpp"

class MinimalProgressBar: public ProgressBar{
  public:
    
    MinimalProgressBar()  {
      _finalized = false;
    }
    
    ~MinimalProgressBar() {
    }
    
    void display() {
      REprintf("Progress:");
    }
    
    void update(float progress) {
      if (_finalized) return;
      REprintf("+");
    }
    
    void end_display() {
      if (_finalized) return;
      REprintf("\n");
      _finalized = true;
    }
    
    private:
  
      bool _finalized;
          
};

// [[Rcpp::export]]
double long_computation_minimal(int nb, bool display_progress=true) {
    MinimalProgressBar pb;
    double sum = 0;
    Progress p(nb, display_progress, pb);
    for (int i = 0; i < nb; ++i) {
        if (Progress::check_abort() )
            return -1.0;
        for (int j = 0; j < nb; ++j) {
            sum += R::dlnorm(i+j, 0.0, 1.0, 0);
        }
        p.increment(); 
    }
    return sum + nb;
}
```

```{r long_computation_minbar_call, eval = FALSE}
long_computation_minimal(10)
```    

### Remaining time estimation

The possibility to setup own progress bar displays allows for more sophisticated implementations. Here's an example of a progress bar, that looks exactly like the default `SimpleProgressBar`, but adds an estimation of the remaining time for the process to finish.

```{Rcpp eta}
#ifndef _RcppProgress_ETA_PROGRESS_BAR_HPP
#define _RcppProgress_ETA_PROGRESS_BAR_HPP

#include <R_ext/Print.h>
#include <ctime>
#include <stdio.h>
#include <sstream>
#include <string.h>

// [[Rcpp::depends(RcppProgress)]]
#include "progress_bar.hpp"

// for unices only
#if !defined(WIN32) && !defined(__WIN32) && !defined(__WIN32__)
#include <Rinterface.h>
#endif

class ETAProgressBar: public ProgressBar{
  public: // ====== LIFECYCLE =====
    
    /**
    * Main constructor
    */
    ETAProgressBar()  {
      _max_ticks = 50;
      _ticks_displayed = 0;
      _finalized = false;
      _timer_flag = true;
    }
    
    ~ETAProgressBar() {
    }
    
    public: // ===== main methods =====
      
      void display() {
        REprintf("0%%   10   20   30   40   50   60   70   80   90   100%%\n");
        REprintf("[----|----|----|----|----|----|----|----|----|----|\n");
        flush_console();
      }
      
      // update display
      void update(float progress) {
        
        // stop if already finalized
        if (_finalized) return;
        
        // start time measurement when update() is called the first time
        if (_timer_flag) {
          _timer_flag = false;
          // measure start time
          time(&start);
        } else {
          
          // measure current time
          time(&end);
          
          // calculate passed time and remaining time (in seconds)
          double pas_time = std::difftime(end, start);
          double rem_time = (pas_time / progress) * (1 - progress);
          
          // convert seconds to time string
          std::string time_string = _time_to_string(rem_time);
          
          // create progress bar string 
          std::string progress_bar_string = _current_ticks_display(progress);
          
          // ensure overwriting of old time info
          int empty_length = time_string.length();
          std::string empty_space = std::string(empty_length, ' ');
          
          // merge progress bar and time string
          std::stringstream strs;
          strs << "|" << progress_bar_string << "| " << time_string << empty_space;
          std::string temp_str = strs.str();
          char const* char_type = temp_str.c_str();
          
          // print: remove old and replace with new
          REprintf("\r");
          REprintf("%s", char_type);
          
          // finalize display when ready
          if(progress == 1) {
            _finalize_display();
          }  
        }
      }
      
      void end_display() {
        update(1);
      }
      
      
      protected: // ==== other instance methods =====
        
        // convert double with seconds to time string
        std::string _time_to_string(double seconds) {
          
          int time = (int) seconds;
          
          int hour = 0;
          int min = 0;
          int sec = 0;
          
          hour = time / 3600;
          time = time % 3600;
          min = time / 60;
          time = time % 60;
          sec = time;
          
          std::stringstream time_strs;
          if (hour != 0) time_strs << hour << "h ";
          if (min != 0) time_strs << min << "min ";
          if (sec != 0) time_strs << sec << "s ";
          std::string time_str = time_strs.str();
          
          return time_str;
        }
        
        // update the ticks display corresponding to progress
        std::string _current_ticks_display(float progress) {
          
          int nb_ticks = _compute_nb_ticks(progress);
          
          std::string cur_display = _construct_ticks_display_string(nb_ticks);
          
          return cur_display;
        }
        
        // construct progress bar display
        std::string _construct_ticks_display_string(int nb) {
          
          std::stringstream ticks_strs;
          for (int i = 0; i < (_max_ticks - 1); ++i) {
            if (i < nb) {
              ticks_strs << "*";
            } else {
              ticks_strs << " ";
            }
          }
          std::string tick_space_string = ticks_strs.str();
          
          return tick_space_string;
        }
        
        // finalize
        void _finalize_display() {
          if (_finalized) return;
          
          REprintf("\n");
          flush_console();
          _finalized = true;
        }
        
        // compute number of ticks according to progress
        int _compute_nb_ticks(float progress) {
          return int(progress * _max_ticks);
        }
        
        // N.B: does nothing on windows
        void flush_console() {
#if !defined(WIN32) && !defined(__WIN32) && !defined(__WIN32__)
          R_FlushConsole();
#endif
        }
        
        private: // ===== INSTANCE VARIABLES ====
          int _max_ticks;   		// the total number of ticks to print
          int _ticks_displayed; 	// the nb of ticks already displayed
          bool _finalized;
          bool _timer_flag;
          time_t start,end;
          
};

#endif

 
// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>

// [[Rcpp::export]]
double long_computation_eta(int nb, bool display_progress=true) {
    ETAProgressBar pb;
    double sum = 0;
    Progress p(nb, display_progress, pb);
    for (int i = 0; i < nb; ++i) {
        if (Progress::check_abort() )
            return -1.0;
        for (int j = 0; j < nb; ++j) {
            sum += R::dlnorm(i+j, 0.0, 1.0, 0);
        }
        p.increment(); 
    }
    return sum + nb;
}
```

```{r long_computation_eta_call}
long_computation_eta(10000) 
```
