---
title: Custom progress bars for RcppProgress
author: Karl Forner and Clemens Schmid
license: GPL (>= 2)
tags: progress bar
summary: Demonstrates how to implement custom progress bars for long computations in C++.
---

[RcppProgress](http://cran.r-project.org/web/packages/RcppProgress/index.html) 
is a tool to help you monitor the execution time of your C++ code, by
providing a way to interrupt the execution inside the C++ code, and also to
display a progress bar indicative of the state of your computation. Additionally, 
it is compatible with multi threaded code, for example using OpenMP. 
[This article](http://gallery.rcpp.org/articles/using-rcppprogress/) explains the 
basic setup.

Since version 0.4 it became more simple to create custom progress bars. We will 
show here how to do this. Our final example implementation displays an estimate of the remaining time (ETA).

### A minimal example

Imagine you added a progress bar with RcppProgress to your function
`long_computation()` following the example from the first article mentioned above.

```{Rcpp long_computation}
// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
#include <progress_bar.hpp>
// [[Rcpp::export]]
double long_computation(int nb, bool display_progress=true) {
  double sum = 0;
  Progress p(nb*nb, display_progress);
  for (int i = 0; i < nb; ++i) {
      if (Progress::check_abort() )
          return -1.0;
      for (int j = 0; j < nb; ++j) {
          p.increment(); 
          sum += R::dlnorm(i+j, 0.0, 1.0, 0);
      }
  }
  return sum + nb;
}
```

```{r long_computation_call}
long_computation(10)
```

What you get is a basic and useful console visualization that looks somehow like this: 

```
0%   10   20   30   40   50   60   70   80   90   100%
[----|----|----|----|----|----|----|----|----|----|
******************************
```

That's the default, platform independent display in RcppProgress defined in 
[SimpleProgressBar.hpp](https://github.com/kforner/rcpp_progress/blob/master/inst/include/simple_progress_bar.hpp). It's OK for most purposes to give you an idea how much work 
is done and it also allows you to make a very intuitive estimation about how long 
it's going to take to finish. But of course that's not everything a progress bar 
*could* show you. A progress bar could give you information about the running 
progress or about performance parameters of your system. It could contain calculated 
estimates of passed and remaining time. After all it could just look much more fancy 
to impress your colleagues.

RcppProgress makes it now very easy to create your own implementation of a progress 
bar class. Your own class has to be derived from the abstract class `ProgressBar` that 
defines some basic virtual methods:

```{Rcpp ProgressBar, eval=FALSE}
class ProgressBar {
  public:
    virtual ~ProgressBar() = 0;
    virtual void display() = 0;
    virtual void update(float progress) = 0;
    virtual void end_display() = 0;
};
```

`display()` starts the display, that will be updated by subsequent calls of
`update()`. `end_display` finalizes it. Your progress bar implementation should
not rely on the destructor to finalize the display.

A very minimal setup could look something like this: 

```{Rcpp minbar, eval = TRUE}
#include <R_ext/Print.h>

// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
#include "progress_bar.hpp"

class MinimalProgressBar: public ProgressBar{
  public:
    
    MinimalProgressBar()  {
      _finalized = false;
    }
    
    ~MinimalProgressBar() {
    }
    
    void display() {
      REprintf("Progress: ");
    }
    
    void update(float progress) {
      if (_finalized) return;
      REprintf("+");
    }
    
    void end_display() {
      if (_finalized) return;
      REprintf("\n");
      _finalized = true;
    }
    
    private:
  
      bool _finalized;
          
};

// [[Rcpp::export]]
double long_computation_minimal(int nb, bool display_progress=true) {
    MinimalProgressBar pb;
    double sum = 0;
    Progress p(nb, display_progress, pb);
    for (int i = 0; i < nb; ++i) {
        if (Progress::check_abort() )
            return -1.0;
        for (int j = 0; j < nb; ++j) {
            sum += R::dlnorm(i+j, 0.0, 1.0, 0);
        }
        p.increment(); 
    }
    return sum + nb;
}
```

```{r long_computation_minbar_call}
long_computation_minimal(10)
```    

The `display()` method in this example does nothing more than printing the word 
`Progress`. `update()` concatenates a `+` symbol every time `Progress::increment()` is 
called. The result looks like this:

```
Progress: ++++++++++
```

In comparison to the example of the default progress bar above, I moved the 
call to `increment()` out of the second level and into the first level loop to keep
the amount of console output at bay. `update()` also checks if the display is `_finalized`.
`end_display` triggers the finalization.  

### Remaining time estimation

Based on the minimal template described above, you can implement more sophisticated 
progress bars. Here's an example of one that looks exactly like the default 
`SimpleProgressBar`, but adds an estimation of the remaining time for the process to finish. 
You can find a complete package setup with the code for this ETAProgressBar 
[here](https://github.com/kforner/rcpp_progress/tree/master/inst/examples/RcppProgressETA). 
Here we only highlight some crucial aspects of the implementation.  
Unfortunately the [Rinterfaces.h header is only available for Unix-like systems](https://stackoverflow.com/questions/47623478/creating-a-progress-update-by-replacing-output-in-the-r-console-from-c-c/47624175?noredirect=1#comment82228757_47624175). 
Therefore this only works for Unix-like systems -- a less cool version for windows can be found [here]().

The ETAProgressBar requires some methods from the standard library:

```{Rcpp eta2, eval = FALSE}
#if !defined(WIN32) && !defined(__WIN32) && !defined(__WIN32__)
#include <Rinterface.h>
#endif
```

```{Rcpp eta3, eval = FALSE}
private: 
  int _max_ticks;
  bool _finalized;
  bool _timer_flag;
  time_t start,end;
```

```{Rcpp eta13, eval = FALSE}    
void display() {
  REprintf("0%%   10   20   30   40   50   60   70   80   90   100%%\n");
  REprintf("[----|----|----|----|----|----|----|----|----|----|\n");
  flush_console();
}
```

```{Rcpp eta23, eval = FALSE}          
void update(float progress) {
  
  // stop if already finalized
  if (_finalized) return;
  
  // start time measurement when update() is called the first time
  if (_timer_flag) {
    _timer_flag = false;
    // measure start time
    time(&start);
  } else {
    
    // measure current time
    time(&end);
    
    // calculate passed time and remaining time (in seconds)
    double pas_time = std::difftime(end, start);
    double rem_time = (pas_time / progress) * (1 - progress);
    
    // convert seconds to time string
    std::string time_string = _time_to_string(rem_time);
    
    // create progress bar string 
    std::string progress_bar_string = _current_ticks_display(progress);
    
    // ensure overwriting of old time info
    int empty_length = time_string.length();
    std::string empty_space = std::string(empty_length, ' ');
    
    // merge progress bar and time string
    std::stringstream strs;
    strs << "|" << progress_bar_string << "| " << time_string << empty_space;
    std::string temp_str = strs.str();
    char const* char_type = temp_str.c_str();
    
    // print: remove old and replace with new
    REprintf("\r");
    REprintf("%s", char_type);
    
    // finalize display when ready
    if(progress == 1) {
      _finalize_display();
    }  
  }
}
```

```{Rcpp eta4, eval = FALSE}
std::string _time_to_string(double seconds) {
  
  int time = (int) seconds;
  
  int hour = 0;
  int min = 0;
  int sec = 0;
  
  hour = time / 3600;
  time = time % 3600;
  min = time / 60;
  time = time % 60;
  sec = time;
  
  std::stringstream time_strs;
  if (hour != 0) time_strs << hour << "h ";
  if (min != 0) time_strs << min << "min ";
  if (sec != 0) time_strs << sec << "s ";
  std::string time_str = time_strs.str();
  
  return time_str;
}
        
```

```{Rcpp eta5, eval = FALSE}
std::string _current_ticks_display(float progress) {
  
  int nb_ticks = _compute_nb_ticks(progress);
  
  std::string cur_display = _construct_ticks_display_string(nb_ticks);
  
  return cur_display;
}

std::string _construct_ticks_display_string(int nb) {
  
  std::stringstream ticks_strs;
  for (int i = 0; i < (_max_ticks - 1); ++i) {
    if (i < nb) {
      ticks_strs << "*";
    } else {
      ticks_strs << " ";
    }
  }
  std::string tick_space_string = ticks_strs.str();
  
  return tick_space_string;
}

int _compute_nb_ticks(float progress) {
  return int(progress * _max_ticks);
}
        
```

```{Rcpp eta7, eval = FALSE}   
void flush_console() {
#if !defined(WIN32) && !defined(__WIN32) && !defined(__WIN32__)
          R_FlushConsole();
#endif
}
```
